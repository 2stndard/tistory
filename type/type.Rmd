---
title: "R의 Data type, Data structure, Class, Object"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

R에서는 다른 프로그래밍 언어와는 달리 Vector라는 데이터 구조를 제공한다. 물론 C나 C++에서도 Vector 데이터 구조를 지원하지만 이는 기본적으로 제공하는 데이터 구조는 아니고 라이브러리를 통해 제공하는 데이터 구조이며 보통 Array를 사용하여 Vector를 사용하는 경우가 많다. 하지만 R에서 Vector는 매우 중요한 데이터 구조로 사용된다.

## R의 데이터 구조(Data Structure)

데이터 구조(Data Structure)는 데이터 타입을 효율적으로 접근하기 위한 구조, 저장방법, 처리방법의 구조화된 방법을 말한다. 앞서 설명한 R의 데이터 타입을 잘 활용하기 위해서는 R에서 제공하는 데이터 구조(Data Structure)의 특성과 사용 방법을 잘 이해해야 한다.

R에서는 다음과 같이 5개의 데이터 구조를 제공한다.

## R의 객체(Object)와 클래스(Class)

R에서 데이터를 다룰때 앞에서 설명한 데이터 타입, 데이터 구조와 함께 알아야 할 개념이 객체(Object)와 클래스(Class)이다. 이를 설명하기 위해서는 프로그래밍 컨셉에 대해 이해할 필요가 있다.

R의 프로그래밍 컨셉을 논하기 전에 먼저 R은 어떻게 구성되있는지 살펴볼 필요가 있다.

### Core R 프로그램의 코드 구성

R은 C언어, Fortran언어와 R언어를 사용하여 개발된 통계 패키지 프로그램이다. R을 구현한 전체 코드에서 C언어가 약 50%, Fortran 언어가 30% 이하, R언어가 25%정도로 구성되었다고 한다.[^1]

[^1]: <https://blog.revolutionanalytics.com/2011/08/what-language-is-r-written-in.html>

![](http://revolution-computing.typepad.com/.a/6a010534b1db25970b014e8b1a83ca970d-pi)

사실 Fortran 언어의 경우 과거 80년대에 많이 사용되던 언어로 수학계산에 많이 활용되던 언어이다. 필자도 대학 1학년때 수치해석을 위해 잠시 써봤지만 컴퓨팅 환경이 윈도우즈로 넘어오고 C언어에서 많은 수학 계산용 라이브러리가 제공되면서 그 활용도가 매우 떨어졌던것이 사실이다.

C의 경우는 최근 Object Oriented 환경을 받아들여 C++로 발전하고 초기 윈도우즈 환경에서 많이 활용되었기 때문에 아직도 활용도가 큰 언어이다. 특히 C은 Unix OS를 개발하는데 활용했던 언어였고 과거부터 수학 계산에 많이 활용되었던 컴퓨팅 시스템에는 C언어와 Fotran언어를 같이 활용하는 경우가 많았다. 이러한 컨셉을 바탕으로 R을 개발하였다. 그래서 R에서는 C언어로 작성된 코드와 Fotran으로 작성된 코드를 실행시킬수 있다. 우리가 지금도 사용하는 많은 R 패키지는 C언어로 만들어졌다.

### 프로그래밍 컨셉

프로그래밍 컨셉은 프로그램을 구성하는 코드의 구성과 실행되는 흐름을 말한다. 이 프로그래밍 컨셉은 컴퓨터의 발달에 따라 변경되어 왔다.

#### 순차적 프로그래밍(Sequential Programming)

컴퓨터가 처음 개발되어 활용되는 단계에서의 프로그래밍 컨셉은 순차적 프로그래밍(Sequential Programming)이었다. 첫번째 라인부터 마지막 라인까지 순차적으로 코딩이 실행되면서 프로그램이 실행되는 방식으로 주로 GW-Basic, Assembly언어와 같은 언어가 순차적 프로그래밍의 대표적 언어이다.

#### 구조적 프로그래밍(Structural Programming) , 절차형 프로그래밍(Procedural Programming)

이후 구조적 프로그래밍(Structured Programming, 혹은 절차형 프로그래밍(Procedural Programming))이 도입되었는데 프로그래밍에 함수라는 개념을 도입함으로써 프로그래밍의 실행 순서를 구조화하는 방법이다. 주로 70년대에 크게 활용되는 프로그래밍 컨셉으로 가장 유명한 것이 Unix OS를 개발하는데 사용되어진 C가 대표적이다.

#### 객체지향 프로그래밍(Object Oriented Programming)

이때까지의 프로그래밍 컨셉은 주로 코드의 흐름을 조절함으로써 프로그램이 작동하는 형태였다. 하지만 이후 80년대 후반에 들어오면서 프로그램의 흐름이 코드의 흐름보다는 객체 중심으로 흘러가는 객체지향 프로그래밍(Object Oriented Programming)으로 바뀌어 갔다. OOP는 여러가지 특징이 있지만 Class와 Object의 개념을 도입했다는 특성이 있다. 데이터 타입과 데이터가 작동하는 방법(Method)를 Class로 정의하고 이 Class로부터 정의된 Object를 통해 프로그램을 실행시키는 프로그래밍 컨셉이다

#### 함수형 프로그래밍(Functional Programming)

이후 2010년이 되면서 OOP는 다시 함수형 프로그래밍(Functional Programming) 컨셉으로 바뀌어 가고 있다. 앞에서 설명했던 프로그래밍 컨셉들로 작성된 프로그램들을 유지보수할때 가장 큰 문제는 스파게티 코드라고 하는 잔뜩 꼬여있는 코드를 해석하는 것이었다. 특히 프로그램이 대형화하면서 이 스파게티 코드로 작성된 프로그램은 작성자가 없이는 유지보수하는 것이 힘들어서 차라리 다시 만드는게 더 좋을 때가 많아졌다. 이러한 단점을 극복하기 위해 가능한한 작고 많은 함수들을 만들고 이들을 조합하여 쓰는 형태의 프로그래밍 컨셉이 등장하게 되었다.

![<https://mangkyu.tistory.com/111>](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%253A%252F%252Fblog.kakaocdn.net%252Fdn%252FEjKha%252FbtqUeXDkUpM%252F54da0e07OWNO5ANhz5Vsu1%252Fimg.png)

### R의 프로그래밍 컨셉

그렇다면 R은 위에서 설명한 여러 프로그래밍 컨셉중에 어떤 컨셉을 적용하고 있을까? R에서 사용하는 프로그래밍 컨셉은 함수형 프로그래밍 컨셉과 객체지향 프로그래밍 컨셉을 모두 사용하고 있다. R에서 적용하는 객체지향 컨셉과 함수형 컨셉이 어떻게 구현되었는지 살펴보자

### 객체지향 컨셉

R에서는 객체지향 프로그래밍 컨셉에서 제공하는 여러가지 특징 중에 대표적으로 제공하는 특징이 다형성(Polymorphism)과 캡슐화(Encapsulateion)이다. [^2]

[^2]: <https://adv-r.hadley.nz/oo.html#oop-systems>

#### 다형성(Polymorphism)

다형성은 함수에 전달되는 인수의 데이터 타입가 다르다고 하더라도 같은 함수의 이름으로 사용하는 특성을 말한다. 예를 들어 구조적 프로그래밍 언어로 유명한 C의 경우 함수의 인수로 전달된 숫자에 1을 더하는 함수를 만든다고 하면 C에서는 고유한 함수에 전달되는 매개변수의 데이터 타입이 사전에 설정되어야 하기 때문에 다음과 같이 여러개의 함수를 만들수 밖에 없다.

```{r eval=FALSE}
result = add_one_int(int);

result = add_one_double(double);
```

하지만 다형성을 제공하는 C++의 경우 다음과 같이 같은 함수명을 사용할 수 있어 코딩이 훨씬 직관적이 된다.

```{r eval=FALSE}
result = int.add_one();

result = double.add_one();
```

R에서는 다형성이 어떻게 사용되는가? 가장 대표적인 다형성 함수는 `summary()`이다. 다음의 예를 살펴보자.

```{r}
library(datasets)
##  숫자형 타입에 적용되는 Summary()
summary(iris$Sepal.Length)

## 팩터(factor) 타입에 적용되는 summary()
summary(iris$Species)
```

위에서 보이는 바와 같이 함수의 인자로 전달되는 데이터의 타입에 따라 함수의 동작이 달라지는 특징을 다형성이라고 한다.

이러한 함수 호출법은 아마도 파이썬 유저라면 익숙하게 느껴질 것이다. 하지만 R 유저에게는 익숙하지 않을 것이다. 사실 R에서는 객체지향 프로그래밍 언어에서 제공하는 형식으로 다형성을 지원하지 않고 함수적 다형성(Functional Polymorphism) 형태로 지원한다. 예를 들어 OOP 다형성의 함수는 `object.function(...)`의 형태로 호출하지만 함수적 다형성은 `function(object, ...)`의 형태로 호출된다. tidyverse 패키지에서는 `object |> function(...)`의 형태로 호출된다.

#### 캡슐화(Encapsulate) : Class와 Object

캡슐화는 객체지향 언어의 핵심인 객체에 대한 특성이다. 구조형 프로그래밍에서는 프로그램에서 사용하는 변수(Variable)과 함수를 각각 정의하고 사용한다. 하지만 객체지향 프로그래밍에서는 변수와 함수를 하나의 객체로 묶어 프로그래밍하는 특성을 캡술화(Encapsulation)이라 한다.

캡슐화라는 특성을 실제로 구현하는 방법으로 제시하는 것이 Class이다. Class는 사용해야할 데이터인 속성(Attribute)와 멤버 변수를 다루는 함수인 메쏘드(Method)를 하나로 묶어 캡슐화(Encapsulate)하여 객체(Object)를 생성하기 위한 프로토타입을 말한다. 말이 좀 어려울 것 같다. 뭐든지 정의는 어렵다.. 아래의 그림을 보자..

![<https://medium.com/future-vision/intro-to-oop-with-python-39ba63967e45>](https://miro.medium.com/max/875/1*xiYI_rl-_pX_27BAjxBL3g.png)

위의 그림에서 포켓몬이라는 클래스가 정의되어 있다. 포켓몬 클래스에는 속성으로 문자형 데이터인 포켓몬 이름, 포켓몬 타입, 정수형 데이터인 포켓몬 건강의 세가지 데이터를 사용하고 있고 attack(), dodge(), evolve()의 세가지 함수를 메쏘드로 포함되어 있다. 이 클래스를 사용해서 포켓몬의 한 객체인 피카츄라는 객체를 생성하였다.

따라서 Class에 포함되는 속성은 R에서 제공하는 기초 데이터 타입과 데이터 구조를 사용자의 필요에 따라 적절히 조합하거나 이미 정의된 Class를 사용하여 설정된다. R에서 제공하는 기초 주요 데이터 타입은 다음과 같다.

-   character : 문자형 데이터 타입

-   numeric : 숫자형 데이터 타입

-   integer : 정수형 데이터 타입

-   logical : 논리연산 데이터 타입

-   complex : 복소수형 데이터 타입

그리고 이들 데이터 타입을 사용하여 R에서 제공하는 데이터 구조형(Data Structure)는 다음의 6가지이다. 데이터 구조(Data Structure)는 데이터 타입을 효율적으로 접근하기 위한 구조, 저장방법, 처리방법의 구조화된 방법을 말한다. 앞서 설명한 R의 데이터 타입을 잘 활용하기 위해서는 R에서 제공하는 데이터 구조(Data Structure)의 특성과 사용 방법을 잘 이해해야 한다.

-   atomic vector: 단일 데이터 타입으로 구성된 1차원 데이터 구조

-   matrix : 단일 데이터 타입으로 구성된 2차원 데이터 구조

-   array : 단일 데이터 타입으로 구성된 3차원 이상 데이터 구조

-   list : 다수 데이터 타입으로 구성된 1차원 데이터 구조

-   data.frame : 다수 데이터 타입으로 구성된 2차원 데이터 구조

R은 많은 프로그래밍 언어에서 제공하지 않는 특별한 데이터 구조로 factor를 제공한다. factor는 augment(증강) vector로 어떤 문서에서는 R의 데이터 타입으로, 어떤 문서에서는 R의 데이터 구조로 소개한다. 필자는 factor는 데이터 타입으로 보기 보다는 데이터 구조로 보는게 타당하다고 생각한다.

결국 Class에서 사용되는 속성은 위의 기본 데이터 타입과 데이터 구조형을 사용하여 정의될 수 있다. 물론 위의 11가지 외에도 파생된 데이터 타입과 데이터 구조형도 존재하지만, 위의 11가지가 가장 기본적으로 사용되는 데이터 타입과 데이터 구조형이다.(이외에도 더 많은 데이터 타입과 데이터 구조형이 있지만 여기서는 11가지만 언급하겠다.)

그러면 R에서의 객체(Object)는 무엇인가. 객체지향 컨셉에서 언급한 바와 같이 사전에 정의된 설계도(Blue Print)인 Class를 사용하여 실제로 사용하기 위해 만들어진 객체를 의미한다. 위의 그림의 예에서 포켓몬이라는 클래스는 설계도이고 포켓몬이라는 클래스로 피카츄라는 객체가 생성된 것이다. 물론 포켓몬이라는 클래스를 활용하여 꼬부기, 잠만보, 리자몽과같은 포켓몬 객체를 생성할 수 있을 것이다.

R에서는 'Everything that exists in R is an object(R에서 존재하는 모든 것이 객체이다)'로 객체를 정의되고 있다.[^3]

[^3]: John M. Chambers, Extending R, CRC Press, 2017

### R에서 제공하는 Class Type

R에서 이와같은 OOP 컨셉을 지원하기 위해 S3, S4, R4 Class 타입을 제공한다.[^4]

[^4]: <https://adv-r.hadley.nz/oo.html#oop-systems>

#### S3 Class type

R의 개발 역사를 살펴보면 R은 S라는 언어에서 개발된 것으로 나온다. S언어는 70년대 후반 개발되어 80년대까지 사용된 언어라고 한다.(필자는 한번도 구경해 본적이 없다.) 그렇기 때문에 R에는 S의 그림자가 아직도 남아있다. 이 대표적인 그림자가 S3 class와 뒤에서 설명할 S4 class이다.

S3 클래스는 R에서 사용하는 가장 널리 사용되는 Class 이다. S3 클래스는 기본적으로 List를 사용하여 만들수 있기 때문에 사용하기가 편하다는 장점이 있다. 그래서 R에서 미리 정의되어 제공되는 Class는 대부분 S3 클래스로 만들어져 있다. 사용하기 편하다는 장점이 있는 대신 보안상으로 취약하다는 단점이 있다.

위에서 예를 들었던 포켓몬 클래스를 S3 클래스로 다음과 같이 구현할 수 있다.

```{r s3_class}
## 클래스로 만들기 위한 기본 리스트를 하나 만든다. 
p <- list(name = '피카츄', type = '전기', health = 70)

## 현재 클래스는 아직 list
class(p)

## 리스트를 포켓몬 클래스로 변환
class(p) <- '포켓몬'

## 클래스를 확인해보면 '포켓몬'으로 바뀌어 있다. 
class(p)

## 포켓몬 클래스의 피카츄 object의 내용
p
```

그럼 이번에는 포켓몬 클래스의 잠만보 객체를 생성해보자. 

```{r s3_잠만보}
p1 <- list(name = '잠만보', type = '노멀', health = 65)

class(p1) <- '포켓몬'

p1

```

하지만 일반적인 OOP에서는 생성함수(Constructuor Function)을 사용하여 객체를 생성하는 것이 일반적이다. 

```{r s3_constructor, error=TRUE}
# 피카츄 클래스의 생성함수 정의
포켓몬 <- function(n,t,h) {
if(h>100 || h<0)  stop("health는 0에서 100사이이어야 합니다.")
value <- list(name = n, type = t, health = h)
attr(value, "class") <- "포켓몬"
value
}

p1 <- 포켓몬('잠만보', '노멀', 60)

p1

p2 <- 포켓몬('꼬부기', '물', 105)

```


앞서 생성했던 포켓몬 클래스의 잠만보 객체의 health가 60인 객체가 다시 생성되었고 꼬부기 객체는 health가 100이 넘어가서 생성되지 않았다. 

그렇다면 이제 멤버 함수인 메쏘드를 정의해보자. 메쏘드를 정의하는 방법은 R의 함수 선언과 동일하다. 다만 함수명을 설정할때 `함수명.클래스명`으로 설정해야 한다. 

```{r s3_method}
attack.포켓몬 <- function(obj) {
  cat(obj$name, '은(는) ')
  cat(obj$type, '공격을 하였습니다.')
  }

attack.포켓몬(p)

attack.포켓몬(p1)

methods(class = '포켓몬')

```

위와 같이 클래스의 메쏘드가 정의되면 메쏘드 이름과 클래스 이름을 같이 써야하기 때문에 좀 번거롭다. 사실 앞서 설명한 `summary()`의 경우는 함수의 인자에 따라 함수의 동작이 달라진다. 이처럼 함수에 주어지는 매개변수에 따라 동작이 달라지는 함수를 일반(혹은 포괄) 함수(Generic Function)이라고 한다. 이처럼 메쏘드를 만들기 위해서는 `useMethod()`를 사용하면 가능해진다.  


```{r generic}
attack <- function(obj) {
  UseMethod("attack")
}

attack(p1)

```


이렇게 속성과 메쏘드를 가지는 S3 타입의 포켓몬 클래스를 생성하였다. 그렇다면 생성한 클래스가 S3인지 S4인지를 어떻게 알수 있을까?

클래스 타입은 아래와 같이 알아낼 수 있다.


-   S3 : 단일 데이터 타입으로 구성된 1차원 데이터 구조

-   S4 : 단일 데이터 타입으로 구성된 2차원 데이터 구조

-   array : 단일 데이터 타입으로 구성된 3차원 이상 데이터 구조
